name: 'Genesis Kit Build, Test & Spec Check'
description: 'Builds Genesis kit, runs spec tests, checks for breaking changes, and tests deployment'
author: 'Genesis Community'

inputs:
  kit_name:
    description: 'Name of the Genesis kit'
    required: true
  version_bump:
    description: 'Type of version bump (patch, minor, major)'
    required: false
    default: 'patch'
  debug_mode:
    description: 'Skip testing and just create PR for release'
    required: false
    default: 'false'
  go_version:
    description: 'Go version to use for tests'
    required: false
    default: 'go1.23.5.linux-amd64.tar.gz'
  ginkgo_params:
    description: 'Ginkgo test parameters'
    required: false
    default: '-p'
  deploy_env:
    description: 'Deployment environment for testing'
    required: false
    default: 'ci-vsphere-baseline'
  iaas_provider:
    description: 'Infrastructure type (vsphere, aws, gcp, etc)'
    required: false
    default: 'vsphere'
  release_branch:
    description: 'Branch to create PR against for releases'
    required: false
    default: 'main'
  # Infrastructure credentials
  aws_access_key_id:
    description: 'AWS Access Key ID'
    required: false
  aws_secret_access_key:
    description: 'AWS Secret Access Key'
    required: false
  gcp_service_account_key:
    description: 'GCP Service Account Key'
    required: false
  vsphere_username:
    description: 'vSphere Username'
    required: false
  vsphere_password:
    description: 'vSphere Password'
    required: false
  # Genesis/BOSH credentials
  secrets_base:
    description: 'Genesis secrets base'
    required: false
  secrets_token:
    description: 'Genesis secrets token'
    required: false
  secrets_key:
    description: 'Genesis secrets key'
    required: false
  bosh_client:
    description: 'BOSH client'
    required: false
  bosh_client_secret:
    description: 'BOSH client secret'
    required: false
  bosh_environment:
    description: 'BOSH environment'
    required: false
  bosh_ca_cert:
    description: 'BOSH CA certificate'
    required: false
  secrets_seed_data:
    description: 'Seed data for secrets'
    required: false
  github_token:
    description: 'GitHub token for operations'
    required: true

outputs:
  version:
    description: 'The new version number'
    value: ${{ steps.version.outputs.new_version }}
  previous_version:
    description: 'The previous version number'
    value: ${{ steps.version.outputs.previous_version }}
  has_breaking_changes:
    description: 'Whether breaking changes were detected'
    value: ${{ steps.check-breaking.outputs.has_breaking_changes }}
  is_release_commit:
    description: 'Whether the commit message indicates a release'
    value: ${{ steps.check-release-commit.outputs.is_release }}
  release_version:
    description: 'Version to release from commit message'
    value: ${{ steps.check-release-commit.outputs.version }}

runs:
  using: 'composite'
  steps:
    - name: Setup tools
      shell: bash
      run: |
        echo "âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡"
        echo "ğŸ” DEBUG: Starting setup process for Genesis Kit Build & Test"
        echo "âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡"
        
        # Install common tools
        echo "ğŸ” DEBUG: Installing common tools"
        sudo apt-get update
        sudo apt-get install -y build-essential unzip jq
        
        # Echo GitHub Action path
        echo "ğŸ” DEBUG: GitHub Action path: ${{ github.action_path }}"

        # Install Genesis dependencies
        echo "ğŸ” DEBUG: Updating permissions for scripts"
        sudo chmod -R a+rwx ${{ github.action_path }}/ci/scripts/*
        echo "âœ… Permissions updated for scripts"
        
        echo "ğŸ” DEBUG: Installing Genesis and dependencies"
        ${{ github.action_path }}/ci/scripts/ensure-tools.sh
        echo "âœ… Genesis and deps installed successfully"
        echo "âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡âš¡"

    # VERSION MANAGEMENT
    - name: Get current version
      id: current
      shell: bash
      run: |
        echo "ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„"
        echo "ğŸ” DEBUG: Checking current version from version file"
        if [[ -f version ]]; then
          version=$(cat version | grep -oP '(?<=Version: ).*' || echo "0.0.0")
          echo "ğŸ” DEBUG: Found version: $version"
          echo "current_version=$version" >> $GITHUB_OUTPUT
        else
          echo "ğŸ” DEBUG: No version file found, defaulting to 0.0.0"
          echo "current_version=0.0.0" >> $GITHUB_OUTPUT
        fi
        echo "ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„"

    - name: Bump version
      id: version
      shell: bash
      run: |
        echo "ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢"
        echo "ğŸ” DEBUG: Calculating new version according to bump type: ${{ inputs.version_bump }}"
        current="${{ steps.current.outputs.current_version }}"
        echo "ğŸ” DEBUG: Current version: $current"
        
        # Extract version components
        major=$(echo "$current" | cut -d. -f1)
        minor=$(echo "$current" | cut -d. -f2)
        patch=$(echo "$current" | cut -d. -f3)
        echo "ğŸ” DEBUG: Extracted components: major=$major, minor=$minor, patch=$patch"
        
        # Bump version according to type
        case "${{ inputs.version_bump }}" in
          major)
            major=$((major + 1))
            minor=0
            patch=0
            echo "ğŸ” DEBUG: Performing MAJOR version bump"
            ;;
          minor)
            minor=$((minor + 1))
            patch=0
            echo "ğŸ” DEBUG: Performing MINOR version bump"
            ;;
          patch|*)
            patch=$((patch + 1))
            echo "ğŸ” DEBUG: Performing PATCH version bump"
            ;;
        esac
        
        new_version="${major}.${minor}.${patch}"
        echo "ğŸ” DEBUG: New version: $new_version"
        echo "new_version=${new_version}" >> $GITHUB_OUTPUT
        echo "previous_version=$current" >> $GITHUB_OUTPUT
        
        # Update version file
        echo "ğŸ” DEBUG: Updating version file"
        echo "## Version: ${new_version}" > version
        echo "âœ… Version file updated to $new_version"
        echo "ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢ğŸ”¢"

    # Check if this is a release commit
    - name: Check for release commit
      id: check-release-commit
      shell: bash
      run: |
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"
        echo "ğŸ” DEBUG: Checking if this is a release commit"
        # Get the last commit message
        commit_msg=$(git log -1 --pretty=%B)
        echo "ğŸ” DEBUG: Last commit message: $commit_msg"
        
        # Check if it matches a release pattern
        if [[ $commit_msg =~ [Rr][Ee][Ll][Ee][Aa][Ss][Ee][^0-9]*([0-9]+\.[0-9]+\.[0-9]+) ]]; then
          echo "ğŸ” DEBUG: âœ“ This IS a release commit"
          echo "is_release=true" >> $GITHUB_OUTPUT
          echo "version=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
          echo "âœ… Detected release commit for version ${BASH_REMATCH[1]}"
        else
          echo "ğŸ” DEBUG: âœ— This is NOT a release commit"
          echo "is_release=false" >> $GITHUB_OUTPUT
          echo "version=" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ Not a release commit"
        fi
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"

    # BUILD KIT (Required even in debug mode)
    - name: Build Kit
      shell: bash
      env:
        GENESIS_SECRETS_BASE: ${{ inputs.secrets_base }}
        GENESIS_SECRETS_TOKEN: ${{ inputs.secrets_token }}
        GENESIS_SECRETS_KEY: ${{ inputs.secrets_key }}
        KIT_NAME: ${{ inputs.kit_name }}
        KIT_VERSION: ${{ steps.version.outputs.new_version }}
        BUILD_ROOT: "build"
      run: |
        echo "ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸"
        echo "ğŸ” DEBUG: Starting kit build process for $KIT_NAME v$KIT_VERSION"
        sudo chmod -R a+rwx ./*
        echo "ğŸ” DEBUG: Permissions updated for working directory"
        
        echo "ğŸ” DEBUG: Compiling kit..."
        genesis compile-kit --force -v "$KIT_VERSION" -n "$KIT_NAME"
        
        echo "ğŸ” DEBUG: Setting up build directory"
        sudo mkdir -p $BUILD_ROOT/
        sudo chmod -R a+rwx $BUILD_ROOT/
        cp ./$KIT_NAME-$KIT_VERSION.tar.gz $BUILD_ROOT/
        
        echo "ğŸ” DEBUG: Build directory contents:"
        ls -lah $BUILD_ROOT/
        echo "âœ… Build completed successfully"
        echo "ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸ğŸ—ï¸"

    # Conditionally run testing steps
    - name: Create directories for spec check and release notes
      if: inputs.debug_mode == 'true'
      shell: bash
      run: |
        echo "ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ"
        echo "ğŸ” DEBUG: Running in DEBUG MODE - Setting up without tests"
        mkdir -p spec-check
        mkdir -p release-notes
        echo "ğŸ” DEBUG: Created directories for spec checks and release notes"
        echo "âš ï¸ Debug mode enabled - skipping tests and proceeding directly to PR creation"
        
        # Create placeholder files for spec checks
        echo "ğŸ” DEBUG: Creating placeholder files for spec checks"
        echo "SKIPPED IN DEBUG MODE" > spec-check/diff-$(date -u +%Y%m%d%H%M%S)
        
        # Create placeholder for release notes
        echo "ğŸ” DEBUG: Creating placeholder release notes"
        echo "# Release Notes for ${{ inputs.kit_name }} v${{ steps.version.outputs.new_version }}" > release-notes/release-notes.md
        echo "Generated in debug mode - no automated tests were run." >> release-notes/release-notes.md
        echo "âœ… Debug mode setup completed"
        echo "ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ"

    # Setting has_breaking_changes in debug mode
    - name: Set breaking changes flag in debug mode
      if: inputs.debug_mode == 'true'
      id: check-breaking-debug
      shell: bash
      run: |
        echo "ğŸ” DEBUG: Setting breaking changes flag to false in debug mode"
        echo "has_breaking_changes=false" >> $GITHUB_OUTPUT
        echo "â„¹ï¸ Breaking changes detection skipped in debug mode"

    # RUN SPEC TESTS - Skip in debug mode
    - name: Setup Go for tests
      if: inputs.debug_mode != 'true'
      shell: bash
      run: |
        echo "ğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ª"
        echo "ğŸ” DEBUG: Setting up Go for spec tests"
        echo "ğŸ” DEBUG: Using Go version: ${{ inputs.go_version }}"
        sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf ${{ inputs.go_version }}
        echo "ğŸ” DEBUG: Installing Ginkgo test framework"
        go install github.com/onsi/ginkgo/v2/ginkgo@latest
        export PATH=$PATH:~/go/bin
        echo "âœ… Go setup completed"
        go version
        echo "ğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ª"

    - name: Run Spec Tests
      if: inputs.debug_mode != 'true'
      shell: bash
      env:
        GENESIS_SECRETS_BASE: ${{ inputs.secrets_base }}
        GENESIS_SECRETS_TOKEN: ${{ inputs.secrets_token }}
        GENESIS_SECRETS_KEY: ${{ inputs.secrets_key }}
        KIT_VERSION: ${{ steps.version.outputs.new_version }}
      run: |
        echo "ğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ª"
        echo "ğŸ” DEBUG: Running spec tests with Ginkgo"
        sudo chmod -R a+rwx ./*
        export PATH=$PATH:~/go/bin
        
        echo "ğŸ” DEBUG: Changing to spec directory and running tests"
        cd spec
        echo "ğŸ” DEBUG: Running ginkgo with params: ${{ inputs.ginkgo_params }}"
        ginkgo ${{ inputs.ginkgo_params }} .
        echo "âœ… Spec tests completed successfully"
        echo "ğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ªğŸ§ª"

    # SPEC CHANGE CHECK - Skip in debug mode
    - name: Check Specs for breaking changes
      if: inputs.debug_mode != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        CURRENT_VERSION: ${{ steps.version.outputs.new_version }}
        PREVIOUS_VERSION: ${{ steps.version.outputs.previous_version }}
      run: |
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"
        echo "ğŸ” DEBUG: Checking for breaking changes in specs"
        mkdir -p spec-check
        echo "ğŸ” DEBUG: Created spec-check directory"
        
        # Get the most recent tag
        echo "ğŸ” DEBUG: Fetching tags"
        git fetch --tags
        PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        
        if [[ -n "$PREV_TAG" ]]; then
          echo "ğŸ” DEBUG: Found previous tag: $PREV_TAG"
          echo "ğŸ” DEBUG: Checking out previous tag to compare specs"
          git checkout $PREV_TAG
          cp -r spec/results ./spec-check/old-specs
          git checkout -
        else
          echo "ğŸ” DEBUG: No previous tag found, this appears to be the initial release"
        fi
        
        results_file="${GITHUB_WORKSPACE}/spec-check/diff-$(date -u +%Y%m%d%H%M%S)"
        if [[ -n "$PREV_TAG" ]]; then
          echo "ğŸ” DEBUG: Generating spec comparison results"
          echo "Comparing specs with previous release $PREV_TAG" > "$results_file"
          ${{ github.action_path }}/ci/scripts/compare-release-specs.sh "$PREV_TAG" >> "$results_file"
        else
          echo "ğŸ” DEBUG: No comparison needed for initial release"
          echo "Initial release - no spec changes to compare" > "$results_file"
        fi
        echo "âœ… Spec comparison completed"
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"

    - name: Check for breaking changes
      if: inputs.debug_mode != 'true'
      id: check-breaking
      shell: bash
      run: |
        echo "ğŸ” DEBUG: Checking for breaking changes in comparison results"
        if grep -q "BREAKING CHANGE" spec-check/diff-*; then
          echo "âš ï¸ BREAKING CHANGES DETECTED! âš ï¸"
          echo "has_breaking_changes=true" >> $GITHUB_OUTPUT
        else
          echo "âœ… No breaking changes detected"
          echo "has_breaking_changes=false" >> $GITHUB_OUTPUT
        fi

    # INFRASTRUCTURE SETUP FOR DEPLOYMENT - Skip in debug mode
    - name: Setup Infrastructure
      if: inputs.debug_mode != 'true'
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.aws_secret_access_key }}
        GCP_SERVICE_ACCOUNT_KEY: ${{ inputs.gcp_service_account_key }}
        VSPHERE_USERNAME: ${{ inputs.vsphere_username }}
        VSPHERE_PASSWORD: ${{ inputs.vsphere_password }}
      run: |
        echo "ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸" 
        echo "ğŸ” DEBUG: Setting up infrastructure for ${{ inputs.iaas_provider }}"
        # Install infrastructure-specific tools
        case "${{ inputs.iaas_provider }}" in
          vsphere)
            # VSphere specific setup
            echo "ğŸ” DEBUG: Setting up VSphere tools..."
            # Configure VSphere credentials
            mkdir -p ~/.vsphere
            echo "$VSPHERE_USERNAME" > ~/.vsphere/username
            echo "$VSPHERE_PASSWORD" > ~/.vsphere/password
            echo "âœ… VSphere credentials configured"
            ;;
          aws)
            # AWS specific setup
            echo "ğŸ” DEBUG: Setting up AWS CLI..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
            # Configure AWS credentials
            echo "ğŸ” DEBUG: Configuring AWS credentials"
            mkdir -p ~/.aws
            cat > ~/.aws/credentials << EOF
        [default]
        aws_access_key_id = $AWS_ACCESS_KEY_ID
        aws_secret_access_key = $AWS_SECRET_ACCESS_KEY
        EOF
            echo "âœ… AWS CLI installed and configured"
            ;;
          gcp)
            # GCP specific setup
            echo "ğŸ” DEBUG: Setting up GCP CLI..."
            echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
            curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
            sudo apt-get update && sudo apt-get install google-cloud-cli
            # Configure GCP credentials
            echo "ğŸ” DEBUG: Configuring GCP service account"
            echo "$GCP_SERVICE_ACCOUNT_KEY" > /tmp/gcp-key.json
            gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
            rm /tmp/gcp-key.json
            echo "âœ… GCP CLI installed and configured"
            ;;
        esac
        echo "âœ… Infrastructure setup completed for ${{ inputs.iaas_provider }}"
        echo "ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸ğŸ› ï¸" 
    
    # VAULT SETUP - Skip in debug mode
    - name: Setup Vault
      if: inputs.debug_mode != 'true'
      shell: bash
      run: |
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"
        echo "ğŸ” DEBUG: Setting up Vault"
        sudo chmod -R a+rwx ./*
        ${{ github.action_path }}/ci/scripts/init-vault.sh
        echo "âœ… Vault setup completed"
        echo "ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”ğŸ”"

    # DEPLOYMENT TEST - Skip in debug mode
    - name: Deploy and Test
      if: inputs.debug_mode != 'true'
      shell: bash
      env:
        DEPLOY_ENV: ${{ inputs.deploy_env }}
        CI_ROOT: "${{ github.workspace }}/git-ci"
        GITHUB_WORKSPACE: ${{ github.workspace }}
        GENESIS_SECRETS_BASE: ${{ inputs.secrets_base }}
        GENESIS_SECRETS_TOKEN: ${{ inputs.secrets_token }}
        GENESIS_SECRETS_KEY: ${{ inputs.secrets_key }}
        GENESIS_STACK_TRACE: "yes"
        BOSH_CLIENT: ${{ inputs.bosh_client }}
        BOSH_CLIENT_SECRET: ${{ inputs.bosh_client_secret }}
        BOSH_ENVIRONMENT: ${{ inputs.bosh_environment }}
        BOSH_CA_CERT: ${{ inputs.bosh_ca_cert }}
        SECRETS_SEED_DATA: ${{ inputs.secrets_seed_data }}
        KIT_VERSION: ${{ steps.version.outputs.new_version }}
        KIT_SHORTNAME: ${{ inputs.kit_name }}
        BUILD_ROOT: "build"
      run: |
        echo "ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€"
        echo "ğŸ” DEBUG: Starting deployment test to environment $DEPLOY_ENV"
        sudo mkdir -p $CI_ROOT/ci/
        sudo chmod a+rwx $CI_ROOT/ci/
        echo "ğŸ” DEBUG: Setting up CI scripts and environments"
        cp -r ${{ github.action_path }}/ci/scripts/* $CI_ROOT/ci/ci/scripts/
        cp -r ./ci/envs/ $CI_ROOT/ci/envs/
        
        echo "ğŸ” DEBUG: Launching deployment script"
        ${{ github.action_path }}/ci/scripts/deploy.sh
        echo "âœ… Deployment and testing completed successfully"
        echo "ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€"

    # GENERATE RELEASE NOTES - Simplified in debug mode
    - name: Generate Release Notes
      if: inputs.debug_mode != 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        KIT_SHORTNAME: ${{ inputs.kit_name }}
        RELEASE_NOTES_FILE: "release-notes.md"
        GITHUB_ACCESS_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“"
        echo "ğŸ” DEBUG: Generating release notes"
        mkdir -p release-notes
        echo "ğŸ” DEBUG: Running release notes script for version ${{ steps.version.outputs.new_version }}"
        ${{ github.action_path }}/ci/scripts/release-notes.sh \
          "${{ steps.version.outputs.new_version }}" \
          "$(pwd)" \
          "$PREV_TAG" \
          "release-notes/$RELEASE_NOTES_FILE"
        echo "âœ… Release notes generated"
        echo "ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“"

    # CREATE PR FOR RELEASE OR MANUAL TRIGGER
    - name: Create Pull Request for Release
      if: steps.check-release-commit.outputs.is_release == 'true' || inputs.debug_mode == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        KIT_NAME: ${{ inputs.kit_name }}
        VERSION: ${{ steps.check-release-commit.outputs.is_release == 'true' && steps.check-release-commit.outputs.version || steps.version.outputs.new_version }}
        RELEASE_BRANCH: ${{ inputs.release_branch }}
      run: |
        echo "ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„"
        echo "ğŸ” DEBUG: Creating pull request for release v${VERSION}"
        git config --global user.name "Genesis CI Bot"
        git config --global user.email "genesis-ci@example.com"
        echo "ğŸ” DEBUG: Git user configured as Genesis CI Bot"
        
        # Create release branch if it doesn't exist
        release_branch="release/v${VERSION}"
        echo "ğŸ” DEBUG: Working with release branch: $release_branch"
        
        # Check if release branch exists remotely
        echo "ğŸ” DEBUG: Checking if release branch already exists"
        if git ls-remote --heads origin $release_branch | grep -q $release_branch; then
          echo "ğŸ” DEBUG: Release branch $release_branch already exists, checking it out"
          git fetch origin
          git checkout $release_branch || git checkout -b $release_branch origin/$release_branch
        else
          echo "ğŸ” DEBUG: Creating new release branch $release_branch"
          git checkout -b $release_branch
        fi
        
        # Commit changes if any
        echo "ğŸ” DEBUG: Adding and committing changes"
        git add -A
        if [[ "${{ inputs.debug_mode }}" == "true" ]]; then
          git commit -m "Prepare release v${VERSION} (debug mode)" || echo "ğŸ” DEBUG: No changes to commit"
        else
          git commit -m "Prepare release v${VERSION}" || echo "ğŸ” DEBUG: No changes to commit"
        fi
        
        # Push branch
        echo "ğŸ” DEBUG: Pushing branch to origin"
        git push origin $release_branch
        
        # Check if PR already exists
        echo "ğŸ” DEBUG: Checking if PR already exists"
        PR_EXISTS=$(curl -s -X GET \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/pulls?head=release/v${VERSION}&base=${RELEASE_BRANCH}&state=open" | jq length)
        
        if [[ "$PR_EXISTS" -gt 0 ]]; then
          echo "ğŸ” DEBUG: PR already exists for this release branch, skipping PR creation"
        else
          # Create PR if it doesn't exist
          echo "ğŸ” DEBUG: Creating new PR for release"
          pr_title="Release v${VERSION}"
          if [[ "${{ inputs.debug_mode }}" == "true" ]]; then
            pr_title="${pr_title} (MANUAL RELEASE - NO TESTS)"
          fi
          
          pr_body="Release preparation for version ${VERSION}

          $(if [[ "${{ inputs.debug_mode }}" == "true" ]]; then
            echo "âš ï¸ MANUAL RELEASE - TESTING WAS SKIPPED âš ï¸"
            echo "This PR was created in debug mode. No automated tests were run."
          else
            echo "Generated from release commit."
          fi)

          $(cat release-notes/release-notes.md 2>/dev/null || echo "No release notes available.")"
          
          # Create PR
          echo "ğŸ” DEBUG: Sending PR creation request to GitHub API"
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$GITHUB_REPOSITORY/pulls" \
            -d '{
              "title": "'"${pr_title}"'",
              "body": "'"${pr_body}"'",
              "head": "'"${release_branch}"'",
              "base": "'"${RELEASE_BRANCH}"'"
            }'
        fi
        echo "âœ… Pull request process completed"
        echo "ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„ğŸ”„"

    - name: Add explanation comment to PR
      if: (steps.check-release-commit.outputs.is_release == 'true' || inputs.debug_mode == 'true')
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        KIT_NAME: ${{ inputs.kit_name }}
        VERSION: ${{ steps.check-release-commit.outputs.is_release == 'true' && steps.check-release-commit.outputs.version || steps.version.outputs.new_version }}
        PR_COMMENT_FILE: "${{ github.action_path }}/docs/pr-comment-template.md"
      run: |
        echo "ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬"
        echo "ğŸ” DEBUG: Adding explanation comment to pull request"
        # Get the PR number from the previous step
        echo "ğŸ” DEBUG: Fetching PR information"
        PR_RESPONSE=$(curl -s -X GET \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/pulls?head=release/v${VERSION}&base=${{ inputs.release_branch }}&state=open")

        PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.[0].number')

        if [[ "$PR_NUMBER" == "null" || -z "$PR_NUMBER" ]]; then
          echo "âš ï¸ Could not find the PR number. Cannot add comment."
          exit 1
        fi

        echo "ğŸ” DEBUG: Found PR #$PR_NUMBER"

        # Read the comment template file or use default if not found
        echo "ğŸ” DEBUG: Looking for PR comment template"
        if [[ -f "$PR_COMMENT_FILE" ]]; then
          PR_COMMENT=$(cat "$PR_COMMENT_FILE")
          echo "ğŸ” DEBUG: Using comment template from file"
        else
          # Default comment if template file doesn't exist
          echo "ğŸ” DEBUG: Template file not found, using default comment"
          if [[ "${{ inputs.debug_mode }}" == "true" ]]; then
            PR_COMMENT="# Manual Release Process for ${KIT_NAME} v${VERSION}

            This PR was manually created in debug mode for version ${VERSION}.
            
            ## âš ï¸ IMPORTANT: No automated tests were run! âš ï¸
            
            ## What happens next:
            1. Review the changes
            2. Run any necessary manual tests before merging
            3. Approve and merge this PR to complete the release
            4. The GitHub release will be automatically created after merging
            
            ## Breaking Changes
            Testing was skipped, so no automated breaking change detection was performed.
            Please review changes manually before merging."
          else
            # Default comment if template file doesn't exist and not in debug mode
            PR_COMMENT="# Release Process for ${KIT_NAME} v${VERSION}

            This PR was automatically created as part of the release process for version ${VERSION}.
            
            ## What happens next:
            1. Review the changes and release notes
            2. Run any additional manual tests if needed
            3. Approve and merge this PR to complete the release
            4. The GitHub release will be automatically created after merging
            
            ## Breaking Changes
            $(grep -A 5 "BREAKING CHANGE" spec-check/diff-* 2>/dev/null || echo "No breaking changes detected")
            
            For more information, see the [release documentation](https://your-docs-link)."
          fi
          echo "ğŸ” DEBUG: Default comment template prepared"
        fi

        # Replace placeholders in the comment
        echo "ğŸ” DEBUG: Replacing placeholders in comment template"
        PR_COMMENT=${PR_COMMENT//\{\{VERSION\}\}/$VERSION}
        PR_COMMENT=${PR_COMMENT//\{\{KIT_NAME\}\}/$KIT_NAME}

        # Create a comment on the PR
        echo "ğŸ” DEBUG: Posting comment to PR #$PR_NUMBER"
        curl -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" \
          -d "{
            \"body\": $(echo "$PR_COMMENT" | jq -Rs .)
          }"

        echo "âœ… Comment added to PR #$PR_NUMBER"
        echo "ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬ğŸ’¬"